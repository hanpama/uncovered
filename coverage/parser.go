// Package coverage provides parsing and analysis of Go coverage profiles.
//
// A coverage profile is generated by running tests with the -coverprofile flag:
//
//	go test -coverprofile=coverage.out
//
// The profile contains information about which parts of the code were executed
// during testing. This package parses that profile and extracts uncovered lines.
//
// # Coverage Profile Format
//
// A coverage profile has the following format:
//
//	mode: set
//	file.go:10.5,12.2 1 1
//	file.go:14.5,16.2 2 0
//
// The first line specifies the coverage mode (set, count, or atomic).
// Each subsequent line represents a coverage block with the format:
//
//	filename:startLine.startCol,endLine.endCol numStatements count
//
// Where count is 0 if the block was not executed, or >0 if it was.
package coverage

import (
	"bufio"
	"fmt"
	"io"
	"strconv"
	"strings"
)

// Profile represents a coverage profile
type Profile struct {
	Mode   string
	Blocks []*ProfileBlock
}

// ProfileBlock represents a single coverage block
type ProfileBlock struct {
	FileName      string
	StartLine     int
	StartCol      int
	EndLine       int
	EndCol        int
	NumStatements int
	Count         int
}

// ParseProfile parses a coverage profile from a reader
func ParseProfile(r io.Reader) (*Profile, error) {
	scanner := bufio.NewScanner(r)
	profile := &Profile{
		Blocks: make([]*ProfileBlock, 0),
	}

	lineNum := 0
	for scanner.Scan() {
		line := scanner.Text()
		lineNum++

		// First line contains the mode
		if lineNum == 1 {
			if strings.HasPrefix(line, "mode: ") {
				profile.Mode = strings.TrimPrefix(line, "mode: ")
				continue
			}
			return nil, fmt.Errorf("invalid coverage profile: first line must start with 'mode:'")
		}

		// Skip empty lines
		if strings.TrimSpace(line) == "" {
			continue
		}

		// Parse coverage block
		block, err := parseBlock(line)
		if err != nil {
			return nil, fmt.Errorf("line %d: %w", lineNum, err)
		}
		profile.Blocks = append(profile.Blocks, block)
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return profile, nil
}

// parseBlock parses a single coverage block line
// Format: filename:startLine.startCol,endLine.endCol numStatements count
func parseBlock(line string) (*ProfileBlock, error) {
	// Split by space to separate filename:positions, numStatements, and count
	parts := strings.Fields(line)
	if len(parts) != 3 {
		return nil, fmt.Errorf("invalid block format: expected 3 fields, got %d", len(parts))
	}

	// Parse filename and positions
	fileAndPos := parts[0]
	lastColon := strings.LastIndex(fileAndPos, ":")
	if lastColon == -1 {
		return nil, fmt.Errorf("invalid format: missing colon separator")
	}

	fileName := fileAndPos[:lastColon]
	positions := fileAndPos[lastColon+1:]

	// Parse positions: startLine.startCol,endLine.endCol
	posParts := strings.Split(positions, ",")
	if len(posParts) != 2 {
		return nil, fmt.Errorf("invalid position format: expected 2 parts, got %d", len(posParts))
	}

	startParts := strings.Split(posParts[0], ".")
	if len(startParts) != 2 {
		return nil, fmt.Errorf("invalid start position format")
	}

	endParts := strings.Split(posParts[1], ".")
	if len(endParts) != 2 {
		return nil, fmt.Errorf("invalid end position format")
	}

	startLine, err := strconv.Atoi(startParts[0])
	if err != nil {
		return nil, fmt.Errorf("invalid start line: %w", err)
	}

	startCol, err := strconv.Atoi(startParts[1])
	if err != nil {
		return nil, fmt.Errorf("invalid start column: %w", err)
	}

	endLine, err := strconv.Atoi(endParts[0])
	if err != nil {
		return nil, fmt.Errorf("invalid end line: %w", err)
	}

	endCol, err := strconv.Atoi(endParts[1])
	if err != nil {
		return nil, fmt.Errorf("invalid end column: %w", err)
	}

	numStatements, err := strconv.Atoi(parts[1])
	if err != nil {
		return nil, fmt.Errorf("invalid number of statements: %w", err)
	}

	count, err := strconv.Atoi(parts[2])
	if err != nil {
		return nil, fmt.Errorf("invalid count: %w", err)
	}

	return &ProfileBlock{
		FileName:      fileName,
		StartLine:     startLine,
		StartCol:      startCol,
		EndLine:       endLine,
		EndCol:        endCol,
		NumStatements: numStatements,
		Count:         count,
	}, nil
}

// IsCovered returns true if this block was covered
func (b *ProfileBlock) IsCovered() bool {
	return b.Count > 0
}
